# Birdscanner v2
# Last modified: ons sep 02, 2020  01:16
# Sign: JN

# Input files
GENOMES, = glob_wildcards("data/genomes/{genome}.gz")
REFERENCES, = glob_wildcards("data/reference/{ref}.fas")

# First rule
rule all:
    """
    TODO: Figure out which lines that should be kept
    """
    input:
        expand("run/tmp/{ref}.hmm", ref=REFERENCES),
        expand("results/genomes/{genome}", genome=GENOMES),
        "run/tmp/genes.done"

# 1. cat_reference_fas
# Uses: bash 5.0.17, awk v5.0.1
#rule cat_reference_fas:
#    """
#    Concatenate all reference fasta files to one (reference.fas),
#    while relabelling fasta headers.
#    TODO: make parallel.
#    """
#    input:
#        expand("data/reference/{REFERENCE}.fas", REFERENCE=REFERENCES)
#    output:
#        temp("run/plast/reference.fas")
#    shell:
#        """for f in {input} ; do awk -v a=$(basename "$f" .fas) '/>/{{$0=">"a"__"++n}}1' "$f"  >> {output} ; done"""
rule cat_reference_fas:
    """
    Concatenate all reference fasta files to one (reference.fas),
    while relabelling fasta headers.
    """
    output:
        temp("run/plast/reference.fas")
    shell:
        "find data/reference -type f -name \*.fas -exec cat {{}} \+ > {output}"

# 2. split_genome_fasta
# Uses: bash 5.0.17, splitfast, pigz v2.4
rule split_genome_fasta:
    """
    Split fasta sequences longer than length=100,000.
    """
    input: 
        "data/genomes/{genome}.gz"
    output: 
        temp("run/plast/{genome}.split.fas")
    threads:
        4
    params:
        length = "100000"
    shell:
        "splitfast -m {params.length} <(pigz -p {threads} -d -c {input}) > {output}"

# 3. make_genome_plast_db
# Uses: bash 5.0.17, makeblastdb v2.9.0+ from blast v2.9.0
rule make_genome_plast_db:
    """
    Make plast database.
    """
    input:
        "run/plast/{genome}.split.fas",
    output:
        temp(touch("run/tmp/{genome}.makeblastdb.done"))
    params:
        dbtype = "nucl",
        parse_seqids = "-parse_seqids"
    shell:
        "makeblastdb -in {input} -dbtype {params.dbtype} {params.parse_seqids}"

# 4. run_plast
# Uses: bash 5.0.17, plast v2.3.2
rule run_plast:
    """
    Run plast with all concatenated reference sequences as query,
    and the splitted genome fasta as data base.
    """
    input:
        db_done= "run/tmp/{genome}.makeblastdb.done",
        query = "run/plast/reference.fas"
    output:
        protected("run/plast/{genome}.plast.tab")
    threads:
        workflow.cores
    params:
        maxhitperquery = "1",
        bargraph = "-bargraph"
    shell:
        "plast -p plastn -i {input.query} -d run/plast/{wildcards.genome}.split.fas -o {output} -a {threads} -max-hit-per-query {params.maxhitperquery} {params.bargraph}"

# 5. get_scaffold_ids
# Uses: bash 5.0.17, awk v5.0.1, sort v8.30
rule get_scaffold_ids:
    """
    The idea is that for each species, we would expect one best hit, and we wish to see which of the scaffolds that most often provides the best hit.
    We wish to search with hmms only against the scaffolds having sufficiently long hits in the plast search.
    Plast outfmt 1:
    query ID, subject ID, percent identities, alignment length, nb. misses, nb. gaps, query begin, query end, subject begin, subject end, e-value, bit score
    We will extract hits where ('alignment length' > minlen), and then we first sort the table on query ID, then sort the table on 'bit score' in descending order, and finally go down
    the list and keep unique 'subject ID'. Note: There is room here to include a scaffold only if having some bit score or e-value.
    """
    input:
        "run/plast/{genome}.plast.tab"
    output:
        temp("run/tmp/{genome}.scaffolds.ids")
    params:
        minlen = "50"
    shell:
        """
        awk '$4>{params.minlen}' {input} | \
        sort -t$'\t' -k1,1 -k12rg | \
        awk -F $'\t' '!x[$1]++' | \
        awk -F $'\t' '{{print $2}}' | \
        sort -u > {output}
        """

# 6. get_reference_ids
# Uses: bash 5.0.17, awk v5.0.1, sort v8.30
rule get_reference_ids:
    """
    Get IDs (file names) for those reference gene files that have a best plast hit with length above minlen.
    NOTE: Room here for more filtering if needed.
    """
    input:
        "run/plast/{genome}.plast.tab"
    output:
        temp("run/tmp/{genome}.ref.ids")
    params:
        minlen = "50"
    shell:
        """
        awk '$4>{params.minlen}' {input} | \
        sort -t$'\t' -k1g -k12rg | \
        awk -F $'\t' '!x[$1]++' | \
        awk -F $'__' '{{print $1 ".hmm"}}' | \
        sort -u > {output}
        """

# 7. select_scaffolds
# Uses: bash 5.0.17, blastdbcmd v2.9.0+
rule select_scaffolds:
    """
    Extract the scaffolds with best plast hits from the splitted genome fasta.
    """
    input:
        db = "run/plast/{genome}.split.fas",
        idfile = "run/tmp/{genome}.scaffolds.ids"
    output:
        temp("run/plast/{genome}.plast.fas")
    params:
        dbtype = "nucl",
        outfmt = "%f"
    shell:
        "blastdbcmd -db {input.db} -dbtype {params.dbtype} -entry_batch {input.idfile} -outfmt {params.outfmt} -out {output}"

# 8. fasta_to_stockholm
# Uses: bash 5.0.17, fasta2stockholm.pl
rule fasta_to_stockholm:
    """
    Fasta to Stockholm MSA conversion.
    """
    input:
        "data/reference/{ref}.fas"
    output:
        temp("run/tmp/{ref}.sto")
    shell:
        "fasta2stockholm.pl {input} > {output}"

# 9. create_hmms
# Uses: bash 5.0.17, hmmbuild from HMMER 3.3
rule create_hmms:
    """
    Create hmms from Stockholm format.
    """
    input:
        "run/tmp/{ref}.sto"
    output:
        temp("run/tmp/{ref}.hmm")
    shell:
        "hmmbuild --dna {output} {input}"

# 10. select_hmms
# Uses: bash 5.0.17, cat v8.30, find v4.7.0, grep v3.4
rule select_hmms:
    """
    Select those hmm from tmp files that have matches in plast, and concatenate them.
    TODO: Currently, we do NOT have information on the gene from the plast output (.plast.tab):
    we have the fasta headers from the queries, which in the example files are taxon abbreviaitons.
    We can generate the gene-information by transforming the fasta headers while creating the
    reference.fas file.
    """
    input:
        "run/tmp/{genome}.ref.ids"
    output:
        temp("run/hmmer/{genome}.hmm")
    shell:
        "cat $(find run/tmp -type f -name \*.hmm | grep -f {input}) > {output}"

# 11. run_hmmpress
# Uses: bash 5.0.17, hmmpress from HMMER 3.3
rule run_hmmpress:
    """
    Run hmmpress.
    """
    input:
        "run/hmmer/{genome}.hmm"
    output:
        temp(touch("run/tmp/{genome}.hmmpress.done"))
    shell:
        "hmmpress {input}"

# 12. run_nhmmer
# Uses: bash 5.0.17, nhmmer from HMMER 3.3
rule run_nhmmer:
    """
    Run nhmmer: the selected scaffolds against the selected hmms.
    """
    input:
        "run/tmp/{genome}.hmmpress.done",
        hmm = "run/hmmer/{genome}.hmm",
        query = "run/plast/{genome}.plast.fas"
    output:
        protected("run/hmmer/{genome}.nhmmer.out")
    params:
        notextw = "--notextw"
    threads:
        workflow.cores
    shell:
        "nhmmer {params.notextw} --cpu {threads} --tblout {output} {input.hmm} {input.query}"

# 13. parse_nhmmer
# Uses: bash 5.0.17, perl v5.30.0, parse_nhmmer.pl v1.0
rule parse_nhmmer:
    """
    Parse nhmmer output.
    """
    input:
        hmmer = "run/hmmer/{genome}.nhmmer.out",
        fas = "run/plast/{genome}.plast.fas"
    output:
        directory("results/genomes/{genome}"),
    params:
        stats = "--stats",
        prefix = "{genome}",
        fastaheader = "{genome}"
    shell:
        "perl workflow/scripts/parse_nhmmer.pl -f {params.fastaheader} -p {params.prefix} -i {input.hmmer} -g {input.fas} -d {output} {params.stats}"

# 14. gather_genes
# Uses: bash 5.0.17, perl v5.30.0, gather_genes.pl v1.0
# TODO: replace the find command in shell
rule gather_genes:
    """
    Gather genes from parsed nhmmer output in genome folders.
    """
    input:
        expand("results/genomes/{genome}", genome=GENOMES)
    output:
        dir = directory("results/genes"),
        file = temp(touch("run/tmp/genes.done"))
    shell:
        "perl workflow/scripts/gather_genes.pl --outdir={output.dir} $(find results/genomes -type d)"

# Remove output, keep results and protected files
rule clean:
    shell:
        "rm run/plast/*.split.fas.* run/hmmer/*.hmm.*"

# Remove all output, including results.
rule distclean:
    shell:
        "rm -rf run/plast/* run/hmmer/* run/tmp/* results/genes/* results/genomes/*"

## Remove hmmer db files
#hmm_db_formats = ["h3f", "h3i", "h3m", "h3p"]
#rule rm_hmmer:
#    input:
#        expand("run/hmmer/{genome}.hmm.{ext}", genome=GENOMES, ext=hmm_db_formats)
#    output:
#        temp(touch("did_rm_hmm"))
#    shell:
#        "rm {input}"
#
## Remove plast db files
#plast_db_formats = ["nhr", "nin", "nog", "nsd", "nsi", "nsq"]
#rule rm_plast:
#    input:
#        expand("run/plast/{genome}.split.fas.{ext}", genome=GENOMES, ext=plast_db_formats)
#    output:
#        temp(touch("did_rm_plast"))
#    shell:
#        "rm {input}"

# When finished
# TODO: 
#     remove untracked files in run/ when finished
#     treat run/ as temp?
#     Create results/genomes/ and results/genes/ at runtime?
#onsuccess:
#

